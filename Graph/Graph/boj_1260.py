# -*- coding: utf-8 -*-
"""BOJ_1260.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dxwU4VeIYMc6V5tSu_B-pVohd3xNo_Bf
"""

from collections import deque

n, m, start = map(int, input().split())
graph = [[] for _ in range(n+1)]
for i in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

for i in graph:
    i.sort()

visited = [False for _ in range(n+1)]

def dfs(x):
    visited[x] = True
    print(x, end=' ')

    for i in graph[x]:
        if visited[i] == False:
            dfs(i)

def bfs(start):
    visited = [False for _ in range(n+1)]
    visited[start] = True
    q = deque()
    q.append(start)

    while q:
        x = q.popleft()
        print(x, end=' ')
        for i in graph[x]:
            if visited[i] == False:
                visited[i] = True
                q.append(i)





dfs(start)
print()
bfs(start)

s = input()

while len(s) % 3 != 0:
    s = '0' + s

res = ''

for i in range(len(s)-1, -1, -3):
    res += str(int(s[i-2]) * 4 + int(s[i-1]) * 2 +  int(s[i]) * 1)

print(res[::-1])

print(oct(int(input(), 2))[2:])

def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
        
v, e = map(int, input().split())

parent = [i for i in range(v+1)]
ls = list()
for _ in range(e):
    c, a, b = map(int, input().split())
    if c == 0:
        union_parent(parent, a, b)
    if c == 1:
        if find_parent(parent, a) != find_parent(parent, b):
            print('NO')
        else:
            print('YES')

import sys
import heapq
INF = sys.maxsize
input = sys.stdin.readline

N = int(input())
M = int(input())
graph = [[] for _ in range(N+1)]
distance = [INF for _ in range(N+1)]

for _ in range(M):
    a,b,c = map(int,input().split())
    graph[a].append((b,c))
start,end = map(int,input().split())

def dijkstra(start):
    distance[start] = 0
    q = []
    heapq.heappush(q,(0,start))
    while q:
        dist,now = heapq.heappop(q)
        if dist < distance[now]:
            continue
        for i in graph[now]:
            cost = dist + i[1]
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q,(cost,i[0]))
dijkstra(start)
print(distance[end])

111